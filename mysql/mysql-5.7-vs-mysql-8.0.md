# Mysql 5.7 VS Mysql 8.0



MySQL 8.0과 MySQL 5.7(5.x 시리즈의 마지막 주요 버전) 사이에는 여러 중요한 차이점이 있습니다. MySQL 8.0은 많은 신기능, 성능 개선, 보안 강화 등을 포함하며, MySQL을 사용하는 애플리케이션의 요구사항을 충족시키기 위한 여러 가지 중요한 업데이트를 제공합니다. 아래는 주요 차이점들의 개요입니다:

#### 1. **데이터 딕셔너리**

* **MySQL 8.0:** 내장된 데이터 딕셔너리를 사용합니다. 이는 시스템 테이블의 정보(예: 테이블, 인덱스, 컬럼, 외래 키 등)를 InnoDB에서 직접 관리함으로써 성능을 향상시키고 메타데이터 관리를 단순화합니다. 이는 파일 기반의 메타데이터 관리(FRM 파일) 대신 사용됩니다.
* **MySQL 5.7:** 각 데이터베이스 객체에 대한 메타데이터를 파일 시스템에 저장하는 FRM 파일을 사용합니다.

#### 2. **문자 집합 및 정렬 규칙**

* **MySQL 8.0:** 기본 문자 집합으로 utf8mb4를 사용하며, 이는 MySQL의 문자 처리에서 보다 광범위한 유니코드 문자를 지원합니다.
* **MySQL 5.7:** 기본 문자 집합은 utf8이며, utf8mb4도 사용할 수 있지만 기본 설정은 아닙니다.

#### 3. **윈도우 함수와 CTE(Common Table Expressions)**

* **MySQL 8.0:** SQL 표준의 윈도우 함수와 공통 테이블 표현식(CTE)을 지원합니다. 이 기능들은 복잡한 쿼리를 보다 쉽게 작성할 수 있게 해 줍니다.
* **MySQL 5.7:** 이러한 기능들을 지원하지 않습니다.

#### 4. **인덱싱 및 검색**

* **MySQL 8.0:** 인비저블 인덱스, 디센딩 인덱스 지원 등의 새로운 인덱싱 기능을 제공합니다. 또한, JSON 데이터 타입의 성능 개선과 전체 텍스트 검색 기능이 향상되었습니다.
* **MySQL 5.7:** JSON 데이터 타입을 도입했지만, 8.0만큼의 성능 최적화나 기능성을 제공하지는 않습니다.

#### 5. **보안**

* **MySQL 8.0:** 보안이 크게 강화되었습니다. 새로운 인증 플러그인(caching\_sha2\_password)이 기본으로 설정되며, SSL/TLS 연결이 기본적으로 활성화됩니다. 또한, 보안 관련 다양한 기능과 향상된 비밀번호 정책을 제공합니다.
* **MySQL 5.7:** 보안 기능도 제공하지만, 8.0에서 제공하는 새로운 인증 메커니즘과 비교하면 다소 제한적입니다.

#### 6. **성능**

* **MySQL 8.0:** InnoDB 스토리지 엔진의 성능이 크게 향상되었습니다. 다중 스레드 리플리케이션, 더 나은 DDL 작업 처리 등을 통해 전반적인 성능과 확장성이 개선되었습니다.
* **MySQL 5.7:** 상당한 성능 개선이 있었으나, 8.0의 새로운 최적화 기능에는 미치지 못합니다.

#### 7. **복제 및 데이터 복구**

* **MySQL 8.0:** 복제 기능이 개선되어, 보다 효율적인 데이터 복구와 고가용성 구성이 가능합니다. Group Replication, Multi-Source Replication 등의 기능이 포함되어 있습니다.
* **MySQL 5.7:** 복제 기능을 지원하지만, 8.0에서 도입된 새로운 복제 기능과 비교하면 기능적으로 제한적입니다.

MySQL 8.0은 이전 버전 대비 많은 새로운 기능과 개선 사항을 제공하여, 개발자와 데이터베이스 관리자가 보다 효율적으로 작업할 수 있도록 돕습니다. 하지만, 기존 시스템을 업그레이드하기 전에는 호환성과 새로운 기능에 대한 테스트를 충분히 수행해야 합니다.



## 인덱싱 및 검색

MySQL 8.0은 인덱싱 및 검색 기능에 있어서 MySQL 5.7 대비 몇 가지 중요한 개선사항과 새로운 기능을 도입했습니다. 이러한 변화는 데이터 검색의 효율성을 높이고, 개발자가 보다 세밀하게 데이터를 관리할 수 있도록 설계되었습니다. 여기에는 다음과 같은 주요 차이점이 포함됩니다:

#### 1. **디센딩 인덱스 (Descending Indexes)**

* **MySQL 8.0:** 디센딩 인덱스를 지원합니다. 이를 통해 개발자는 데이터를 오름차순 또는 내림차순으로 인덱싱할 수 있으며, 이는 특정 쿼리에 대한 검색 성능을 최적화하는 데 도움이 됩니다. 예를 들어, 최신 항목을 자주 조회하는 애플리케이션에서 내림차순 인덱스는 데이터 검색 속도를 향상시킬 수 있습니다.
* **MySQL 5.7:** 디센딩 인덱스를 직접 지원하지 않습니다. 모든 인덱스는 기본적으로 오름차순으로 생성됩니다.

#### 2. **인비저블 인덱스 (Invisible Indexes)**

* **MySQL 8.0:** 인비저블 인덱스 기능을 도입했습니다. 이 기능을 사용하면 인덱스를 "보이지 않게" 만들 수 있어, 옵티마이저가 해당 인덱스를 사용하지 않게 됩니다. 이는 인덱스의 영향을 평가하거나, 사용하지 않는 인덱스를 실제로 제거하기 전에 성능 테스트를 수행하고자 할 때 유용합니다.
* **MySQL 5.7:** 이 기능을 지원하지 않습니다. 인덱스를 생성하면 쿼리 옵티마이저가 항상 이를 고려 대상에 포함시킵니다.

#### 3. **JSON 테이블 함수**

* **MySQL 8.0:** JSON 데이터 처리 및 검색 기능이 향상되었습니다. JSON 테이블 함수를 통해 JSON 문서 내의 데이터를 가상의 관계형 테이블로 변환하여 쿼리할 수 있습니다. 이는 JSON 데이터의 복잡한 처리와 분석을 용이하게 합니다.
* **MySQL 5.7:** JSON 데이터 타입을 지원하지만, 8.0에서 제공하는 고급 JSON 처리 기능은 제공하지 않습니다.

#### 4. **향상된 전체 텍스트 검색**

* **MySQL 8.0:** 전체 텍스트 검색 기능이 더욱 개선되었습니다. 특히, ngram 파서를 통해 아시아 언어의 전체 텍스트 검색을 개선하여, 한글, 중국어, 일본어 등의 언어 처리 능력이 향상되었습니다.
* **MySQL 5.7:** 전체 텍스트 검색을 지원하지만, 8.0처럼 다양한 언어에 대한 검색 최적화 기능을 제공하지 않습니다.

이러한 차이점은 MySQL 8.0이 보다 다양한 데이터 검색 및 처리 요구사항을 충족시킬 수 있도록 설계되었음을 보여줍니다. 특히, 디센딩 인덱스와 인비저블 인덱스는 데이터베이스 성능 최적화와 관리에 있어 매우 유용한 도구입니다. JSON 데이터의 향상된 처리는 현대적인 웹 애플리케이션 개발에 필수적인 요소가 되었으며, MySQL 8.0은 이러한 요구사항을 잘 반영하고 있습니다.

## MySQL Ascending index vs Descending index

{% embed url="https://tech.kakao.com/2018/06/19/mysql-ascending-index-vs-descending-index/" %}

## Mysql 에도 캐싱처리가 되나요 ??

네, MySQL에는 쿼리 결과를 캐싱하여 빠르게 응답할 수 있는 메커니즘이 있습니다. MySQL 5.7 이하에서는 `Query Cache`라는 기능을 통해 직접적인 쿼리 캐싱을 지원했습니다. 그러나 MySQL 8.0에서는 `Query Cache` 기능이 제거되었고, 대신 다른 방법으로 성능 최적화를 추구하고 있습니다.

#### MySQL 5.7 이하의 Query Cache

* **Query Cache**는 SQL 쿼리와 그 결과를 메모리에 캐싱하는 기능입니다. 동일한 쿼리가 다시 실행될 때, MySQL은 캐시된 결과를 바로 반환하여 쿼리 실행 시간을 대폭 줄일 수 있습니다. 이 기능은 읽기가 많은 애플리케이션에서 특히 유용했습니다.
* 그러나 Query Cache는 데이터 변경 시 캐시된 쿼리 결과를 무효화해야 하는 비용 때문에, 쓰기가 많은 환경에서는 오히려 성능 저하를 초래할 수 있었습니다. 또한, 대규모 멀티코어 서버에서는 Query Cache의 락 경합(lock contention)이 성능 병목으로 작용할 수 있습니다.

#### MySQL 8.0의 접근 방식

* MySQL 8.0에서는 Query Cache 기능이 제거되었습니다. 대신, InnoDB 스토리지 엔진의 성능 최적화, 더 효율적인 데이터 접근 방식, SQL 최적화 등을 통해 전반적인 데이터베이스 성능을 향상시키는 방향으로 전략을 전환했습니다.
* **InnoDB 버퍼 풀:** MySQL은 InnoDB 스토리지 엔진을 사용하는 경우, 데이터와 인덱스를 메모리 내의 버퍼 풀에 캐싱합니다. 이는 디스크 I/O를 줄이고 읽기 및 쓰기 작업의 성능을 향상시키는 데 기여합니다. 버퍼 풀은 데이터 접근에 대한 캐싱 메커니즘으로 작동하여, Query Cache의 제거와 상관없이 높은 성능을 유지할 수 있도록 돕습니다.
* **성능 스키마 및 옵티마이저 힌트:** MySQL 8.0은 성능 스키마를 통해 쿼리 성능 분석을 지원하며, 개발자가 쿼리나 테이블 접근 방식에 옵티마이저 힌트를 제공할 수 있도록 합니다. 이를 통해 성능 최적화를 더 세밀하게 조정할 수 있습니다.

#### 캐싱과 성능 최적화 대안

* **애플리케이션 레벨 캐싱:** MySQL 8.0 환경에서는 애플리케이션 레벨에서 Redis, Memcached 같은 외부 캐싱 솔루션을 사용하여 쿼리 결과를 캐싱하는 것이 일반적인 접근 방식입니다. 이러한 방식은 데이터베이스 부하를 줄이고, 응답 시간을 단축시키는 데 효과적입니다.

MySQL의 성능 최적화는 단순히 쿼리 캐싱뿐만 아니라 데이터 구조, 인덱싱 전략, 쿼리 설계, 스토리지 엔진 최적화 등 다양한 요소를 포함합니다. 따라서, 전반적인 데이터베이스 성능을 향상시키기 위해서는 이러한 다양한 측면을 종합적으로 고려할 필요가 있습니다.



## Mysql 읽기와 쓰기 성능



MySQL 8.0에서는 Query Cache의 제거와 함께 다양한 성능 최적화 기법을 도입하여 전반적인 데이터베이스 성능을 향상시켰습니다. 그러나 "읽기"와 "쓰기" 작업의 성능 효율성은 여전히 다를 수 있으며, 이는 사용되는 스토리지 엔진, 데이터베이스 구조, 쿼리 최적화, 시스템 구성, 애플리케이션의 특성 등 다양한 요소에 의해 영향을 받습니다.

#### 읽기(Read) 성능 최적화

MySQL 8.0은 읽기 성능을 최적화하기 위해 다음과 같은 기능을 제공합니다:

1. **InnoDB 버퍼 풀:** 데이터와 인덱스 페이지를 메모리에 캐싱하여 디스크 I/O를 줄입니다. 이는 반복적인 읽기 쿼리에 대해 빠른 응답 시간을 제공합니다.
2. **인덱스 최적화:** 보다 효율적인 인덱스 구조와 인덱싱 알고리즘을 사용하여 쿼리 성능을 향상시킵니다.
3. **윈도우 함수와 공통 테이블 표현식(CTE):** 복잡한 쿼리를 보다 효율적으로 작성할 수 있게 해 줍니다.

#### 쓰기(Write) 성능 최적화

쓰기 성능에 대해서도 MySQL 8.0은 여러 개선을 도입했습니다:

1. **리두 로그(Redo Log)의 확장:** 리두 로그 크기를 확장하여 쓰기 작업 중 발생하는 I/O를 최적화합니다.
2. **DML 성능 개선:** Insert, Update, Delete 작업의 성능을 개선하여, 대량의 데이터 조작 시 성능을 향상시킵니다.
3. **병렬 복제:** 복제 성능을 향상시켜 마스터 서버에 대한 쓰기 부하를 효율적으로 분산시킵니다.

#### 읽기 대비 쓰기 성능

* **읽기 작업**은 일반적으로 버퍼 풀과 같은 메모리 캐싱 메커니즘을 통해 상당히 최적화될 수 있으며, 특히 반복적으로 같은 데이터를 읽는 경우 매우 빠른 성능을 보입니다.
* **쓰기 작업**은 데이터의 지속성을 보장하기 위해 디스크 I/O가 필요하며, 트랜잭션 로깅, 데이터 무결성 검사 등 추가적인 작업을 수행해야 합니다. 이로 인해 쓰기 작업은 읽기 작업에 비해 상대적으로 더 많은 자원을 소모할 수 있습니다.

그러나 MySQL 8.0의 성능 최적화 기법은 쓰기 작업의 오버헤드를 줄이고 전반적인 성능을 향상시키는 데 크게 기여합니다. 따라서, MySQL 8.0은 읽기와 쓰기 모두에서 성능 이슈를 줄이고 효율성을 높이기 위한 다양한 기능을 제공합니다. 실제 성능은 애플리케이션의 특성, 데이터 접근 패턴, 시스템 구성 등에 따라 달라질 수 있으므로, 최적의 성능을 위해서는 이러한 요소들을 종합적으로 고려하여 데이터베이스를 설계하고 최적화해야 합니다.

## 리두 로그

리두 로그(Redo Log)는 MySQL의 InnoDB 스토리지 엔진에서 사용하는 중요한 메커니즘 중 하나입니다. 이 로그는 데이터베이스의 내구성(Durability)과 회복력을 보장하는 데 핵심적인 역할을 합니다. 특히, 시스템 장애가 발생했을 때 데이터베이스를 안전한 상태로 복구하는 데 사용됩니다.

#### 리두 로그의 기본 개념

* **목적:** 리두 로그는 데이터베이스 변경 사항(쓰기 작업)을 기록하는 로그 파일입니다. 이 로그를 사용하여 데이터베이스가 비정상적으로 종료된 후에도 마지막 일관된 상태로 복구할 수 있습니다.
* **작동 방식:** InnoDB는 데이터 변경을 먼저 리두 로그에 기록한 다음, 실제 데이터 파일에 변경 사항을 적용합니다. 이 과정을 'Write-Ahead Logging (WAL)'이라고 합니다. 시스템이 실패했을 때, 리두 로그에 기록된 정보를 사용하여 마지막 체크포인트 이후의 모든 변경 사항을 재실행(리두)하여 데이터의 일관성을 유지합니다.

#### 리두 로그의 확장

MySQL 8.0에서는 리두 로그의 크기를 확장할 수 있는 옵션이 제공됩니다. 리두 로그 파일의 크기는 `innodb_log_file_size`와 `innodb_log_files_in_group` 설정을 통해 조정할 수 있습니다. 리두 로그의 총 크기는 이 두 설정 값의 곱으로 결정됩니다.

* **innodb\_log\_file\_size:** 개별 리두 로그 파일의 크기를 설정합니다.
* **innodb\_log\_files\_in\_group:** 로그 그룹 내의 로그 파일 수를 설정합니다.

#### 리두 로그 확장의 중요성

* **성능:** 적절한 크기의 리두 로그는 데이터베이스의 쓰기 성능에 중대한 영향을 미칩니다. 너무 작은 리두 로그는 로그의 자주 회전(rotate)을 초래하여 성능 저하를 일으킬 수 있습니다. 반면, 충분히 큰 리두 로그는 쓰기 작업을 효율적으로 처리할 수 있게 하여 전반적인 성능을 향상시킵니다.
* **복구 시간:** 또한, 리두 로그의 크기는 시스템 장애 후 복구 시간에도 영향을 미칩니다. 적절한 크기의 로그는 복구 프로세스의 속도를 최적화할 수 있습니다.

#### 설정 조정 시 고려 사항

리두 로그 크기를 조정할 때는 시스템의 디스크 용량, 쓰기 부하의 양, 복구 시간 요구 사항 등을 고려해야 합니다. 너무 큰 리두 로그는 불필요한 디스크 공간을 소비하고, 복구 시간을 늘릴 수 있으므로, 시스템의 운영 환경과 요구 사항에 맞게 적절한 크기를 설정하는 것이 중요합니다.

MySQL의 성능과 안정성을 최적화하기 위해서는 리두 로그 설정을 포함한 다양한 InnoDB 파라미터들을 적절히 조정하고 관리하는 것이 필요합니다.
